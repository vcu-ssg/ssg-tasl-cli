"""
Slides from guide
"""

import os
import re
import sys
import html
import shutil
import frontmatter
import markdown
from loguru import logger
from markdown.extensions.toc import TocExtension
from bs4 import BeautifulSoup, Tag

from markdown_it import MarkdownIt
from markdown_it.token import Token
from mdformat.renderer import MDRenderer

#logger.remove()
#logger.add(sys.stderr, level="INFO")


def load_markdown_with_frontmatter(markdown_file_path):
    """ Loads a QMD file, keeping frontmatter separate """
    try:
        with open(markdown_file_path, 'r', encoding='utf-8') as file:
            post = frontmatter.load(file)
            logger.info(f"loading QMD, keeping content: {markdown_file_path}")
        return post
    except FileNotFoundError:
        logger.error(f"File not found: {markdown_file_path}")
        return None
    except Exception as e:
        logger.error(f"Error loading Markdown with front matter: {e}")
        return None

def process_markdown(markdown_content):
    """ Process markdown, converting to html """
    # Initialize a Markdown parser with the Table of Contents (TOC) extension
    md = markdown.Markdown(extensions=[TocExtension(toc_depth="3")])

    # Parse the Markdown content
    html_content = md.convert(markdown_content)

    # Get the table of contents generated by the TOC extension
    table_of_contents = md.toc

    # Print the table of contents (optional)
#    print("Table of Contents:")
#    print(table_of_contents)

    return html_content

def extract_content_under_h2(h2):
    # Extract the content under the <h2> element until the next <h2> is encountered
    content = []
    next_tag = h2.find_next_sibling()

    while next_tag and next_tag.name != 'h2':
        content.append(str(next_tag))
        next_tag = next_tag.find_next_sibling()

    return '\n'.join(content)

def extract_md_content_under_h2(tokens, header_name):
    """ extract h2 and children from markdown tokens """
    h2_content = []
    capture = False

    for token in tokens:
        if token.type == "heading_open" and token.tag == "h2":
            capture = False  # Stop capturing if a new H2 is found
            next_token = tokens[tokens.index(token) + 1]
            if next_token.type == "inline" and next_token.content == header_name:
                capture = True

        if capture:
            h2_content.append(token)

    return h2_content

def unescape_string(input_string):
    # Replace "\\_" with "_"
    cleaned_string = input_string.replace(r'\_', '_')
    
    # Use regular expression to replace "\\" with "\" except when it's at the end of a line
    # (?!$) is a negative lookahead that ensures we don't replace backslashes at the end of the string
    cleaned_string = re.sub(r'\\\\(?!$)', r'\\', cleaned_string)
    return cleaned_string

def unescape_string1(input_string):
    # Step 1: Unescape HTML characters
    cleaned_string = html.unescape(input_string)
    
    # Step 2: Unescape LaTeX characters
    # Remove double backslashes before LaTeX commands like \alpha, \beta, etc.
    # We can use a simple regex to remove the extra backslash for LaTeX commands
    cleaned_string = re.sub(r'\\\\([a-zA-Z]+)', r'\\\1', cleaned_string)
    
    # If there are other specific LaTeX escapes, you can handle them here
    return cleaned_string

def extract_div_blocks(markdown):
    # Regular expression to find blocks and their classes
    block_pattern = r"::: \{\.(\S+)\}([\s\S]*?):::"

    # Find all matches of the blocks
    blocks = re.findall(block_pattern, markdown)

    # Create a dictionary where the key is the class name and the value is the block content
    block_dict = {block[0]: block[1].strip() for block in blocks}

    for key in block_dict.keys():
        block_dict[key] = unescape_string( block_dict[key] )

    # Remove the matched blocks from the markdown
    cleaned_markdown = re.sub(block_pattern, '<!-- -->', markdown)

    return block_dict, cleaned_markdown

def convert_headers(markdown):
    # Regular expression to match headers starting with ###
    header_pattern = r"^### (.+)$"

    # Substitute ### with ## for all matches
    cleaned_markdown = re.sub(header_pattern, r"## \1", markdown, flags=re.MULTILINE)

    return cleaned_markdown


def convert_headers_outside_containers(markdown):
    # Regular expression to find blocks that start with ::: {.something} and end with :::
    block_pattern = r"::: \{.*?\}([\s\S]*?):::"
    
    # Find all blocks and store their positions
    blocks = [(m.start(), m.end()) for m in re.finditer(block_pattern, markdown)]
    
    # Regular expression to match H3 headers (### something)
    header_pattern = r"^### (.+)$"
    
    # Split the markdown into lines
    lines = markdown.splitlines()
    
    # Function to check if a line index is within any container block
    def is_inside_block(line_start, line_end):
        for block_start, block_end in blocks:
            if block_start <= line_start < block_end or block_start < line_end <= block_end:
                return True
        return False
    
    # Iterate through lines and convert headers that are outside containers
    for i, line in enumerate(lines):
        if line.startswith("###"):
            line_start = sum(len(l) + 1 for l in lines[:i])  # Calculate line start position in the original markdown
            line_end = line_start + len(line)
            
            # If the line is not inside any container, convert it to H2
            if not is_inside_block(line_start, line_end):
                lines[i] = re.sub(header_pattern, r"## \1", line)
    
    # Join lines back together to form the final markdown
    cleaned_markdown = "\n".join(lines)
    
    return cleaned_markdown

def replace_height_in_style(div_element,new_height):
    # Ensure that the input is a div element
    if not isinstance(div_element, Tag) or div_element.name != 'div':
        raise ValueError("Input must be a Beautiful Soup Tag object representing a div element.")

    # Get the style attribute
    style_attribute = div_element.get('style', '')

    # Modify the style attribute
    if 'height' in style_attribute:
        # Split the style attribute into individual styles
        styles = style_attribute.split(';')
        new_styles = []
        for style in styles:
            if 'height' in style:
                # Replace the height attribute
                new_styles.append(f'height:{new_height}')
            else:
                new_styles.append(style)
        # Join the modified styles back together
        new_style_attribute = ';'.join(new_styles)
        # Update the style attribute of the div element
        div_element['style'] = new_style_attribute.strip()

    # Return the modified div element
    return div_element


def process_html_content(post, html_content):
    # You can use BeautifulSoup to parse and manipulate HTML
    # Here, we'll print the headers and their content

    title = post.metadata["title"]
    logger.debug(f"{title}")
    soup = BeautifulSoup(html_content, 'html.parser')

    md = MarkdownIt("gfm-like",{"html": True})  # don't escape html or latex characters.

    s = ""
    s = s + f"\n# {title}\n"

    # write section heading

    for h2 in soup.find_all(['h2']):

        h2_text = h2.text.strip()
        logger.debug(f"{str(h2)}")
        block = extract_content_under_h2( h2 )
        bsoup = BeautifulSoup(block, 'html.parser')

        if h2.has_attr('class'):
            css_classes = h2["class"]
            logger.debug( css_classes )

            if "slide-template-bullet-walk" in css_classes:
#                logger.debug("slide-template-bullet-walk")
                lis = bsoup.find_all(['li'])
                strongs = bsoup.find_all(['strong'])
                logger.info(h2.text.strip())
                image = bsoup.find(['img'])
                logger.debug(str(image))
#                logger.debug( lis )

                texts = []
                for li in lis:
                    logger.debug( li )
                    li_strong_tag = li.find('strong')
                    if li_strong_tag:
                        li_strong_tag.extract()
                        logger.debug(li_strong_tag)
                        logger.debug(li.get_text())
                        li_contents = li.find("p")
                        if not li_contents:
                            li_contents = li
                        logger.debug( li_contents )
                        if li_contents:
                            li_contents.extract()
                            x = str(li_contents)
                            if x.startswith("<p>:"):
                                x = x.lstrip("<p>:").strip()
                                x = "<p>" + x
                            if x.startswith("<li>:"):
                                x = x.lstrip("<li>:").strip()
                                x = "<li>" + x
                            if x.startswith("<li>"):
                                x = x.replace("li>","p>")
                            logger.debug( x )
                            texts.append( x )
                    #texts.append( li.text.strip()

                logger.debug( strongs )
                logger.debug( texts )
                toc = []
                for strong in strongs:
                    toc.append(re.sub(r':$','',strong.text.strip()))

                for i,text in enumerate( texts ):

                    s = s + f"\n## {h2_text}\n\n"
                    s = s + ":::: {.columns}\n"
                    s = s + "::: {.column width=""30%""}\n"
                    for j,item in enumerate( toc ):
                        if i==j:
                            s = s + f"- **{item}**\n"
                        else:
                            s = s + f"- {item}\n"
                    s = s + ":::\n"
                    s = s + "::: {.column width=""40%""}\n"
                    logger.debug( text )
                    s = s + f"{text}\n"
                    s = s + ":::\n"
                    s = s + "::: {.column width=""30%""}\n"
                    s = s + f"![]({image['src']})"
                    if str(block).find("lightbox")>-1:
                        s = s + "{.lightbox}"
                    s = s + "\n"
                    s = s + ":::\n"
                    s = s + "::::\n"
            elif "slide-template-versus" in css_classes:
#                logger.debug("slide-template-versus")
#                logger.debug(h2.text.strip())

                versus_blocks = bsoup.find_all(class_="versus-block")

                for block in versus_blocks:

                    vsoup = BeautifulSoup(str(block),'html.parser')

                    image = vsoup.find(['img'])
                    img = image
#                    logger.debug(str(img))
                    image.extract()
                    s = s + f"\n## {h2_text}\n\n"
                    s = s + ":::: {.columns}\n"
                    s = s + "::: {.column width=""70%""}\n"
                    s = s + str(vsoup.prettify()) + "\n"
                    s = s + ":::\n"
                    s = s + "::: {.column width=""30%""}\n"
                    if img:
                        logger.debug(str(block))
                        s = s + f"![]({img['src']})"
                        if str(block).find("lightbox")>-1:
                            s = s + "{.lightbox}"
                        s = s + "\n"
                    s = s + ":::\n"
                    s = s + "::::\n"
                else:
                    logger.debug(f"unknown class type")

            elif "slide-template-description-p5-widget" in css_classes:
                logger.debug("slide-template-description-p5-widget")

                lis = bsoup.find_all(['li'])
                image = bsoup.find(['img'])

                pis = bsoup.find_all(["p"])
                script = bsoup.find("script")
                script["data-height"] = 400  # force height to 400


                if len(lis)>0:
                    s = s + f"\n\n## {h2_text}\n\n"  

                    s = s + ":::: {.columns}\n"
                    s = s + "::: {.column width=70%}\n"
                    for li in lis:
                        s = s + f"* {li.get_text()}\n\n"
                    s = s + ":::\n"
                    s = s + "::: {.column width=30%}\n"
                    if image:
                        s = s + f"![]({image['src']})"
                    else:
                        s = s + "&nbsp;"
                    x = ""
                    if str(block).find("lightbox")>-1:
                        x = x + ".lightbox "
                    if x != "":
                        x = "{ " + x + "}"
                    s = s + x + "\n\n"
                    s = s + ":::\n"
                    s = s + "::::\n"

                    icnt = 0;
                    for i,pi in enumerate(pis):
                        if icnt==0 and len(pi.get_text())>0:
                            s = s + f"{pi.get_text()}\n\n"
                            icnt = icnt + 1

                s = s + f"\n\n## {h2_text} \n\n"  # drop header for the script, so the script can be bigger

                s = s + "```{=html}\n"
                s = s + str(script) + "\n\n"
                s = s + "```\n"

            elif "slide-template-2-column-with-image" in css_classes:
                logger.debug("slide-template-2-column-with-image")

                lis = bsoup.find_all(['li'])
                image = bsoup.find(['img'])

                pis = bsoup.find_all(["p"])

                h3s = bsoup.find_all(['h3'])
                logger.debug( h3s )

                sections = bsoup.find_all(['section'])
                logger.debug(sections)

                if len(lis)>0:
                    s = s + f"\n\n## {h2_text}\n\n"  

                    s = s + ":::: {.columns}\n"
                    s = s + "::: {.column width=70%}\n"
                    for li in lis:
                        s = s + f"* {li.get_text()}\n\n"
                    s = s + ":::\n"
                    s = s + "::: {.column width=30%}\n"
                    if image:
                        s = s + f"![]({image['src']})"
                    else:
                        s = s + "&nbsp;"
                    x = ""
                    if str(block).find("lightbox")>-1:
                        x = x + ".lightbox "
                    if x != "":
                        x = "{ " + x + "}"
                    s = s + x + "\n\n"
                    s = s + ":::\n"
                    s = s + "::::\n"

                    icnt = 0;
                    for i,pi in enumerate(pis):
                        if icnt==0 and len(pi.get_text())>0:
                            s = s + f"{pi.get_text()}\n\n"
                            icnt = icnt + 1


                for i,section in enumerate( sections ):
    
                    logger.debug( f"{section.find(['h3']).text}"   )
                    s = s + f"\n##\n\n"

                    div_element = section.find('div', {'data-snack-id': True})
                    if div_element:
                        #div_element['style'] = div_element['style'].replace('height:505px', 'height:475px')
                        #div_element['height'] = '475px'
                        #logger.debug(div_element)

                        new_div = replace_height_in_style( div_element,"475px" )
                        logger.debug(new_div)
                        s = s + f"```{{=html}}\n"
                        s = s + new_div.prettify()
                        s = s + "```\n\n"

                    script_element = section.find('script')
                    if script_element:
                        s = s + f"{script_element.prettify()}\n\n"
            else:
                ## if the section is unlabeled, then simply copy the corresponding h2 block
                ## from the original QMD file

                logger.info(f"unlabeled section: {h2_text}")
                tokens = md.parse(post.content)
                results = extract_md_content_under_h2( tokens, h2_text )
                renderer = MDRenderer()
                output_markdown = renderer.render(results, {}, {})
                logger.debug( output_markdown )

                # this is a bug fix.  The generator sometimes print "   :::"
                lines = output_markdown.split("\n")
                for i,line in enumerate(lines):
                    if line.startswith("  :::"):
                        lines[i] = line.replace("  :::",":::")
                output_markdown = "\n".join( lines )

                ## For purposes of converting the guide to slide, any H3 under an H2
                ## will be converted to an H2.
                ## Once this is done, we need to reextract the new content.

                cleaned_markdown = convert_headers_outside_containers( output_markdown )

                logger.debug( cleaned_markdown )
                if not output_markdown == cleaned_markdown:
                    logger.info("Converting H3 to H2 for slides.")

                h2_pattern = r"(## .+)([\s\S]*?)(?=## |\Z)"

                # Find all H2 blocks using the regular expression
                h2_blocks = re.findall(h2_pattern, cleaned_markdown)

                for h2, output_markdown in h2_blocks:
                    logger.debug( h2 )
                    logger.debug( output_markdown )

                    block_dict, cleaned_markdown = extract_div_blocks(output_markdown)

                    logger.debug( block_dict )
                    logger.debug( cleaned_markdown )

                    widths = dict(left="47%",middle="6%",right="47%")
                    if len(block_dict.get("guide-block-right",""))<5:
                        widths = dict(left="98%",middle="1%",right="1%")

                    side_by_side_table = f"""
:::: {{.columns}}
::: {{.column width={widths["left"]}}}
{ unescape_string(block_dict.get("guide-block-left","")) }
:::
::: {{.column width={widths["middle"]}}}
:::
::: {{.column width={widths["right"]}}}
{ unescape_string( block_dict.get("guide-block-right","") )}
:::
::::
"""
                    cleaned_markdown = unescape_string( cleaned_markdown )
                    output_markdown = h2 + "\n" + cleaned_markdown.replace("<!-- -->",side_by_side_table,1)

                    s = s + "\n" + output_markdown + "\n"


        s = s + "\n\n"

#        s = s + block
        
        # Process the content under the current header (if needed)
#        process_header_content(header)

    return s

def write_underline_file( filename, markdown ):
    try:
        with open(filename, 'w', encoding='utf-8') as file:
            file.write( markdown )

    except Exception as e:
        logger.error(f"Error writing underline file '{filename}': {e}")

def write_main_qmd_file( filename, title ):
    """ create a """

    # Define the content you want to write (as a Python dictionary)
    new_yaml_content = {
        'title': title,
        'format': {
            "revealjs": {"include-in-header":[
                {"text": "<script src='https://toolness.github.io/p5.js-widget/p5-widget.js'></script>".strip()}
            ]
            }
        }
    }

#format:
#    revealjs: 
#        include-in-header:
#        - text: |
#            <script src="//toolness.github.io/p5.js-widget/p5-widget.js"></script>


    try:
        # Create a new front matter object

        content = "\n\n{{< include '" + f"{"_"+filename}" + "' >}}\n\n\n"

        post = frontmatter.Post( content )
        post.metadata = new_yaml_content

        # Write the new content to the YAML file

        if os.path.exists(filename):
            logger.warning(f"{filename} exists. Not writing new QMD file.")
        else:
            with open(filename, 'w', encoding='utf-8') as file:
                file.write( frontmatter.dumps(post) )

    except Exception as e:
        logger.error(f"Error writing to YAML file: {e}")

def copy_asset_files(source_folder, destination_folder):
    # Ensure both source and destination folders exist
    if not os.path.exists(source_folder):
        logger.warning(f"Source folder '{source_folder}' does not exist.")
        return
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)

    # Get a list of all files in the source folder
    files = os.listdir(source_folder)

    # Iterate through the files and copy them to the destination folder
    for file_name in files:
        source_file = os.path.join(source_folder, file_name)
        destination_file = os.path.join(destination_folder, file_name)

        # Check if the file already exists in the destination folder
        if os.path.exists(destination_file):
            logger.debug(f"File '{file_name}' already exists in the destination folder.")
        else:
            shutil.copy2(source_file, destination_file)
            logger.debug(f"File '{file_name}' copied to the destination folder.")


def slides_from_qmd( original_filename ):
    """ convert markdown file into opinionated reveal js slides """

    # Get the base filename without extension
    base_filename = os.path.splitext(os.path.basename(original_filename))[0]

    qmd_filename = "../guide/" + original_filename
    html_filename = "../docs/guide/" + os.path.splitext( original_filename )[0] + ".html"

    assets_folder_source = "../docs/guide/" + os.path.join(os.path.split( original_filename )[0], "assets")
    assets_folder_dest = "./assets"

    post = load_markdown_with_frontmatter( qmd_filename )
    if post:

        # Now you can access front matter and content separately.

        html = process_markdown( post.content )

        logger.debug(f"loading html_filename: {html_filename}")
        with open(html_filename, 'r', encoding='utf-8') as html_file:
            # Read the contents of the HTML file
            html_content = html_file.read()
        if not html_content:
            logger.error(f"could not load html_filename: {html_filename}")
            sys.exit(1)

        logger.info( base_filename+".qmd" )

        new_markdown = process_html_content( post, html_content )
#        logger.debug( new_markdown )
        if not new_markdown:
            logger.error(f"Error processing html_filename: {html_filename}")
            sys.exit(1)


        # Generate put an _underline file for use with includes.
        # Generate a QMD file to test the _underline file
        # and move the assets.
        write_underline_file( "_"+base_filename+".qmd", new_markdown )
        write_main_qmd_file( base_filename+".qmd",post.metadata["title"] )
        copy_asset_files( assets_folder_source, assets_folder_dest )




def main():

#    logger.remove(0)
#    logger.add(sys.stderr, level="WARNING")
  
    #slides_from_qmd( filenames[len(filenames)-1] )
    pass

if __name__=="__main__":
    main()
